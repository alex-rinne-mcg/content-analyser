{
  "name": "ZZUPER Meta Post Analysis",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 9 * * 1"
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "operation": "read",
        "documentId": {
          "__rl": true,
          "value": "1ye1nbaT4GyREOJsWuiXVavc_nvXHcDMLU7hqwCqapqY",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": "AI Config",
          "mode": "name"
        }
      },
      "id": "read-ai-config",
      "name": "Read AI Config",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.4,
      "position": [250, 500],
      "credentials": {
        "googleServiceAccount": {
          "name": "Google Service Account account"
        }
      }
    },
    {
      "parameters": {
        "operation": "read",
        "documentId": {
          "__rl": true,
          "value": "1ye1nbaT4GyREOJsWuiXVavc_nvXHcDMLU7hqwCqapqY",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": "Tracker",
          "mode": "name"
        },
        "options": {
          "range": "A1:C2"
        }
      },
      "id": "read-tracker",
      "name": "Read Tracker",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.4,
      "position": [450, 300],
      "credentials": {
        "googleServiceAccount": {
          "name": "Google Service Account account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Calculate date range based on tracker or default to 30 days\nconst tracker = $input.first().json;\nconst lastRunDate = tracker['Last Run Date'] || null;\n\nlet startDate, endDate;\n\nif (lastRunDate) {\n  // Incremental: from last run to now\n  startDate = new Date(lastRunDate);\n  endDate = new Date();\n} else {\n  // First run: last 30 days\n  endDate = new Date();\n  startDate = new Date();\n  startDate.setDate(startDate.getDate() - 30);\n}\n\n// Format for Meta API (Unix timestamp)\nconst startTimestamp = Math.floor(startDate.getTime() / 1000);\nconst endTimestamp = Math.floor(endDate.getTime() / 1000);\n\nreturn {\n  json: {\n    startDate: startDate.toISOString().split('T')[0],\n    endDate: endDate.toISOString().split('T')[0],\n    startTimestamp,\n    endTimestamp,\n    lastPostId: tracker['Last Post ID'] || null\n  }\n};"
      },
      "id": "calculate-date-range",
      "name": "Calculate Date Range",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 300]
    },
    {
      "parameters": {
        "url": "https://graph.facebook.com/v21.0/185121598021398/posts",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "fields",
              "value": "id,message,created_time,permalink_url,full_picture,comments_count,shares_count"
            },
            {
              "name": "limit",
              "value": "100"
            }
          ]
        },
        "options": {}
      },
      "id": "fetch-posts",
      "name": "Fetch Posts",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [850, 300],
      "credentials": {
        "httpHeaderAuth": {
          "name": "Header Auth account 4"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract posts array from Meta API response and filter by date\nconst response = $input.first().json;\nconst posts = response.data || [];\n\n// Get date range from Calculate Date Range node\n// In N8N, we can reference previous nodes that have already executed\nlet dateRange;\ntry {\n  // Try to get date range from Calculate Date Range node\n  const dateRangeNode = $('Calculate Date Range');\n  if (dateRangeNode && dateRangeNode.item) {\n    dateRange = dateRangeNode.item.json;\n  } else {\n    throw new Error('Date range node not found');\n  }\n} catch (e) {\n  // Fallback: calculate date range here if node reference fails\n  // This happens on first run (last 30 days)\n  const endDate = new Date();\n  const startDate = new Date();\n  startDate.setDate(startDate.getDate() - 30);\n  dateRange = {\n    startDate: startDate.toISOString().split('T')[0],\n    endDate: endDate.toISOString().split('T')[0],\n    lastPostId: null\n  };\n}\n\nconst startDate = new Date(dateRange.startDate + 'T00:00:00Z');\nconst endDate = new Date(dateRange.endDate + 'T23:59:59Z');\n\n// Filter posts by date range\nconst filteredPosts = posts.filter(post => {\n  if (!post.created_time) return false;\n  const postDate = new Date(post.created_time);\n  return postDate >= startDate && postDate <= endDate;\n});\n\n// Return each post as a separate item\nreturn filteredPosts.map(post => ({ json: post }));"
      },
      "id": "extract-posts",
      "name": "Extract Posts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [950, 300]
    },
    {
      "parameters": {
        "jsCode": "// Filter out posts that have already been processed\nconst lastPostId = $('Calculate Date Range').item.json.lastPostId;\n\n// If lastPostId is null or empty, keep all posts (first run)\nif (!lastPostId || lastPostId === '') {\n  return $input.all();\n}\n\n// Otherwise, filter out posts with ID matching lastPostId\nreturn $input.all().filter(item => item.json.id !== lastPostId);"
      },
      "id": "filter-new",
      "name": "Filter New",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "url": "=https://graph.facebook.com/v21.0/{{ $json.id }}/insights",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "metric",
              "value": "post_clicks,post_reactions_by_type_total,post_fan_reach,post_video_views"
            },
            {
              "name": "period",
              "value": "lifetime"
            }
            ]
        },
        "options": {
          "response": {
            "fullResponse": false,
            "responseFormat": "json"
          }
        }
      },
      "id": "get-insights",
      "name": "Get Insights",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1250, 300],
      "credentials": {
        "httpHeaderAuth": {
          "name": "Header Auth account 4"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge insights with post data\n// Input is an array of insights responses, one per post\n// We need to match each insights response with its corresponding post\n\nconst items = $input.all();\n\n// Get all posts from Filter New node\nconst allPosts = $('Filter New').all().map(item => item.json);\n\n// Merge each insights response with its corresponding post\nreturn items.map((insightsItem, index) => {\n  const post = allPosts[index];\n  const insightsResponse = insightsItem.json;\n  \n  // Transform insights array to object\n  const insights = {};\n  if (insightsResponse && insightsResponse.data) {\n    insightsResponse.data.forEach(metric => {\n      insights[metric.name] = metric;\n    });\n  }\n  \n  // Also get comments and shares from post if available\n  const comments = post.comments_count || 0;\n  const shares = post.shares_count || 0;\n  \n  return {\n    json: {\n      ...post,\n      insights,\n      comments_count: comments,\n      shares_count: shares\n    }\n  };\n});"
      },
      "id": "merge-insights",
      "name": "Merge Insights",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1350, 300]
    },
    {
      "parameters": {
        "jsCode": "// Calculate performance metrics and scores\n// Process all items\nconst items = $input.all();\n\nreturn items.map(item => {\n  const post = item.json;\n  const insights = post.insights || {};\n  \n  // Extract metrics (using valid metrics for v21.0)\n  const impressions = parseInt(insights.post_fan_reach?.values?.[0]?.value || 0); // Using post_fan_reach as proxy for impressions\n  const reach = parseInt(insights.post_fan_reach?.values?.[0]?.value || 0); // Using post_fan_reach for reach\n  \n  // Handle post_reactions_by_type_total which can be an object like {\"like\": 2, \"love\": 1} or empty object {}\n  const reactionsByType = insights.post_reactions_by_type_total?.values?.[0]?.value || {};\n  let reactions = 0;\n  if (typeof reactionsByType === 'object' && reactionsByType !== null) {\n    // Sum all reaction types (like, love, wow, haha, sorry, anger)\n    reactions = Object.values(reactionsByType).reduce((sum, count) => sum + (parseInt(count) || 0), 0);\n  } else if (typeof reactionsByType === 'number') {\n    reactions = reactionsByType;\n  }\n  \n  const clicks = parseInt(insights.post_clicks?.values?.[0]?.value || 0);\n  const videoViews = parseInt(insights.post_video_views?.values?.[0]?.value || 0);\n  const engagedUsers = 0; // Not available in current metrics\n  const negativeFeedback = 0; // Not available in current metrics\n  \n  // Get comments and shares from post data (using new field names)\n  const comments = parseInt(post.comments_count || 0);\n  const shares = parseInt(post.shares_count || 0);\n  \n  // Calculate rates (using reach/fan_reach as base for calculations)\n  const baseReach = reach || impressions || 1; // Use reach or impressions, fallback to 1 to avoid division by zero\n  const engagementRate = baseReach > 0 ? ((reactions + comments + shares) / baseReach) * 100 : 0;\n  const shareRate = baseReach > 0 ? (shares / baseReach) * 100 : 0;\n  const clickRate = baseReach > 0 ? (clicks / baseReach) * 100 : 0;\n  \n  // Performance score calculation\n  // Score = (engagementRate × 0.4) + (shareRate × 100 × 0.3) + (clickRate × 0.2) + (videoCompletionRate × 0.1)\n  let performanceScore = (engagementRate * 0.4) + (shareRate * 100 * 0.3) + (clickRate * 0.2);\n  \n  // Category determination\n  let category = 'poor';\n  if (performanceScore > 10) category = 'exceptional';\n  else if (performanceScore >= 5) category = 'good';\n  else if (performanceScore >= 2) category = 'average';\n  \n  return {\n    json: {\n      ...post,\n      metrics: {\n        impressions,\n        reach,\n        reactions,\n        comments,\n        shares,\n        clicks,\n        videoViews,\n        engagedUsers,\n        negativeFeedback\n      },\n      rates: {\n        engagementRate: parseFloat(engagementRate.toFixed(2)),\n        shareRate: parseFloat(shareRate.toFixed(4)),\n        clickRate: parseFloat(clickRate.toFixed(2))\n      },\n      performanceScore: parseFloat(performanceScore.toFixed(2)),\n      category\n    }\n  };\n});"
      },
      "id": "calculate-metrics",
      "name": "Calculate Metrics",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "jsCode": "// Check if post is a video based on metrics and URL\n// Process all items\nconst items = $input.all();\n\nreturn items.map(item => {\n  const post = item.json;\n  \n  // Determine if post is a video based on:\n  // 1. post_video_views > 0 (most reliable indicator)\n  // 2. permalink_url contains '/reel/' or '/videos/'\n  const videoViews = post.metrics?.videoViews || post.insights?.post_video_views?.values?.[0]?.value || 0;\n  const permalinkUrl = post.permalink_url || '';\n  \n  const isVideo = videoViews > 0 || permalinkUrl.includes('/reel/') || permalinkUrl.includes('/videos/');\n  \n  // Use post ID as videoId - we'll try to fetch video metadata for all posts\n  // If it's not a video, the API will return an error which we'll handle gracefully\n  const videoId = post.id || null;\n  \n  return {\n    json: {\n      ...post,\n      isVideo,\n      videoId\n    }\n  };\n});"
      },
      "id": "check-if-video",
      "name": "Check If Video",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1850, 300]
    },
    {
      "parameters": {
        "jsCode": "// Merge video data with post (handle both video and non-video posts)\n// Process all items\nconst items = $input.all();\n\nreturn items.map(item => {\n  const post = item.json;\n  const isVideo = post.isVideo || false;\n  \n  // For video posts, we can extract the video URL from permalink_url if needed\n  // For now, we'll just use the permalink_url as the source\n  // Video metadata (length, format) is not available without making an API call\n  // which causes deprecation warnings for non-video posts\n  \n  return {\n    json: {\n      ...post,\n      isVideo,\n      source: isVideo ? post.permalink_url || null : null,\n      length: null, // Not available without API call\n      format: null // Not available without API call\n    }\n  };\n});"
      },
      "id": "merge-video-data",
      "name": "Merge Video Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2150, 300]
    },
    {
      "parameters": {
        "jsCode": "// Build dynamic AI prompt from config sheet\nconst posts = $input.all();\n\n// Get AI config - use try/catch in case sheet doesn't exist yet\nlet config = {};\ntry {\n  const configRows = $('Read AI Config').all();\n  configRows.forEach(row => {\n    const key = row.json['Config Key'];\n    const value = row.json['Value'];\n    if (key && value) {\n      config[key] = value;\n    }\n  });\n} catch (error) {\n  console.log('AI Config sheet not found, using defaults');\n}\n\n// Default values\nconst defaults = {\n  video_analysis_focus: 'Hook effectiveness (first 3 seconds), Pacing and retention, Visual storytelling, Audio impact, CTA timing',\n  static_analysis_focus: 'Copy hook strength, Visual hierarchy, CTA clarity, Format effectiveness, Engagement triggers',\n  audience_context: 'ZZP\\'ers (Dutch independent contractors) aged 25-55. Value independence, price-conscious, skeptical of insurance complexity. Pain points: fear of income loss, confusion about options.',\n  business_context: 'ZZUPER positioning: \"de noodbuffer voor eigen baas\". Challenger brand disrupting traditional disability insurance. Key differentiators: transparent pricing (€39.85/month), no medical exam, lump-sum payouts, flexible cancellation. Current challenge: 97.1% awareness-to-consideration drop-off.',\n  sector_context: 'Four sectors: Bouw (construction, 40%, high injury risk), Transport (25%, long hours), Zorg (healthcare, 20%, burnout), Techniek (technical, 15%, equipment injuries)',\n  output_format: 'JSON with detailed string descriptions',\n  additional_instructions: 'Identify ZZUPER value props: affordable, no medical exam, flexible cancellation, lump-sum payouts. Assess tone: fear-based vs empowerment-based. Flag if messaging could increase drop-off.',\n  tone_preference: 'Professional but accessible, actionable insights for marketing team'\n};\n\n// Merge config with defaults\nObject.keys(defaults).forEach(key => {\n  if (!config[key]) config[key] = defaults[key];\n});\n\n// Build prompt for each post\nreturn posts.map(item => {\n  const post = item.json;\n  const isVideo = post.isVideo || false;\n  \n  const analysisFocus = isVideo ? \n    config.video_analysis_focus : \n    config.static_analysis_focus;\n  \n  const prompt = `Analyze this ZZUPER Facebook post and provide insights in JSON format.\n\nPost Details:\n- ID: ${post.id}\n- Type: ${isVideo ? 'Video' : 'Non-Video'}\n- Created: ${post.created_time}\n- Message: ${post.message || 'No text'}\n- URL: ${post.permalink_url}\n\nPerformance Metrics:\n- Impressions: ${post.metrics.impressions}\n- Reach: ${post.metrics.reach}\n- Reactions: ${post.metrics.reactions}\n- Comments: ${post.metrics.comments}\n- Shares: ${post.metrics.shares}\n- Clicks: ${post.metrics.clicks}\n- Performance Score: ${post.performanceScore}/10\n- Category: ${post.category}\n\n${isVideo ? `Video URL: ${post.source || 'N/A'}\\nVideo Views: ${post.metrics.videoViews || 0}` : ''}\n\n=== AUDIENCE CONTEXT ===\n${config.audience_context}\n\n=== BUSINESS CONTEXT ===\n${config.business_context}\n\n=== SECTOR CONTEXT ===\n${config.sector_context}\n\n=== ANALYSIS FOCUS ===\n${analysisFocus}\n\n=== ADDITIONAL INSTRUCTIONS ===\n${config.additional_instructions}\n\nTone: ${config.tone_preference}\n\nReturn a JSON object with these fields:\n{\n  \"hookEffectiveness\": \"Assess opening impact with specific examples\",\n  \"pacingRetention\": \"Evaluate flow and momentum (video only, N/A for static)\",\n  \"completionFactors\": \"What drives viewers to finish (video only, N/A for static)\",\n  \"visualStorytelling\": \"Analyze visual narrative and composition\",\n  \"audioImpact\": \"Evaluate music/voice effectiveness (video only, N/A for static)\",\n  \"copyEffectiveness\": \"Assess message clarity, audience relevance, business alignment\",\n  \"shareabilityFactors\": \"What makes this shareable within ZZP'er community\",\n  \"audienceResonance\": \"Alignment with audience psychographics and pain points\",\n  \"engagementTriggers\": \"Specific elements driving reactions based on context\",\n  \"replicationFramework\": \"Actionable template for success replication\",\n  \"formatEffectiveness\": \"Format choice effectiveness for message and audience\"\n}\n\nFor non-video posts, set video-specific fields to \"N/A\".\n\nCRITICAL: Evaluate how this post addresses the 97.1% drop-off challenge. Does it build trust? Simplify value prop? Provide social proof?`;\n\n  return {\n    json: {\n      ...post,\n      customPrompt: prompt\n    }\n  };\n});"
      },
      "id": "build-ai-prompt",
      "name": "Build AI Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2200, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "is-video-condition",
              "leftValue": "={{ $json.isVideo }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "split-video-nonvideo",
      "name": "Split Video/Non-Video",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2200, 300]
    },
    {
      "parameters": {
        "url": "={{ $json.permalink_url }}",
        "options": {
          "response": {
            "responseFormat": "file",
            "responsePropertyName": "video"
          },
          "redirect": {
            "followRedirects": true,
            "maxRedirects": 5
          }
        },
        "continueOnFail": true
      },
      "id": "download-video",
      "name": "Download Video",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2300, 200],
      "onError": "continue"
    },
    {
      "parameters": {
        "url": "={{ $json.full_picture }}",
        "options": {
          "response": {
            "responseFormat": "file",
            "responsePropertyName": "image"
          }
        },
        "continueOnFail": true
      },
      "id": "download-image",
      "name": "Download Image",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2300, 400],
      "onError": "continue"
    },
    {
      "parameters": {
        "jsCode": "// Prepare video file for Gemini API\nconst item = $input.first();\n\n// Get video file from binary data\nconst videoFile = item.binary?.video || item.binary?.data;\n\nif (!videoFile) {\n  // If no video file, return post data without video\n  return {\n    json: {\n      ...item.json,\n      hasVideo: false,\n      videoError: 'No video file found'\n    }\n  };\n}\n\n// Convert to base64\nconst base64Video = videoFile.data;\nconst mimeType = videoFile.mimeType || 'video/mp4';\n\nreturn {\n  json: {\n    ...item.json,\n    videoBase64: base64Video,\n    videoMimeType: mimeType,\n    hasVideo: true\n  }\n};"
      },
      "id": "prepare-video-gemini",
      "name": "Prepare Video for Gemini",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2400, 200]
    },
    {
      "parameters": {
        "jsCode": "// Prepare image file for Gemini API\nconst item = $input.first();\n\n// Get image file from binary data\nconst imageFile = item.binary?.image || item.binary?.data;\n\nif (!imageFile) {\n  // If no image file, return post data without image\n  return {\n    json: {\n      ...item.json,\n      hasImage: false,\n      imageError: 'No image file found'\n    }\n  };\n}\n\n// Convert to base64\nconst base64Image = imageFile.data;\nconst mimeType = imageFile.mimeType || 'image/jpeg';\n\nreturn {\n  json: {\n    ...item.json,\n    imageBase64: base64Image,\n    imageMimeType: mimeType,\n    hasImage: true\n  }\n};"
      },
      "id": "prepare-image-gemini",
      "name": "Prepare Image for Gemini",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2400, 400]
    },
    {
      "parameters": {
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent?key={{ $credentials.geminiApi.apiKey }}",
        "sendQuery": false,
        "sendBody": true,
        "contentType": "json",
        "bodyParameters": {
          "parameters": [
            {
              "name": "contents",
              "value": "={{ (() => {\n  const parts = [{\n    text: $json.customPrompt || 'Analyze this ZZUPER Facebook VIDEO post and provide insights in JSON format.'\n  }];\n  \n  if ($json.hasVideo && $json.videoBase64) {\n    parts.push({\n      inlineData: {\n        mimeType: $json.videoMimeType || 'video/mp4',\n        data: $json.videoBase64\n      }\n    });\n  }\n  \n  return JSON.stringify([{ parts }]);\n})() }}"
            }
          ]
        },
        "options": {}
      },
      "id": "ai-analysis-video",
      "name": "AI Analysis (Video)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2500, 200],
      "credentials": {
        "genericCredentialType": {
          "name": "Gemini API"
        }
      }
    },
    {
      "parameters": {
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent?key={{ $credentials.geminiApi.apiKey }}",
        "sendQuery": false,
        "sendBody": true,
        "contentType": "json",
        "bodyParameters": {
          "parameters": [
            {
              "name": "contents",
              "value": "={{ (() => {\n  const parts = [{\n    text: $json.customPrompt || 'Analyze this ZZUPER Facebook NON-VIDEO post (text + image) and provide insights in JSON format.'\n  }];\n  \n  if ($json.hasImage && $json.imageBase64) {\n    parts.push({\n      inlineData: {\n        mimeType: $json.imageMimeType || 'image/jpeg',\n        data: $json.imageBase64\n      }\n    });\n  }\n  \n  return JSON.stringify([{ parts }]);\n})() }}"
            }
          ]
        },
        "options": {}
      },
      "id": "ai-analysis-nonvideo",
      "name": "AI Analysis (Non-Video)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2500, 400],
      "credentials": {
        "genericCredentialType": {
          "name": "Gemini API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse AI response from Gemini (handles both video and non-video posts)\nconst items = $input.all();\n\nreturn items.map(item => {\n  const response = item.json;\n  \n  // Get original post data from the previous AI Analysis node\n  // The AI Analysis nodes receive data from Prepare Video/Image nodes\n  // We need to get the post data that was passed through\n  let postData = {};\n  \n  // Try to get from video path first\n  try {\n    const prepareVideo = $('Prepare Video for Gemini');\n    if (prepareVideo && prepareVideo.item) {\n      const videoData = prepareVideo.item.json;\n      // Remove temporary video fields\n      const { videoBase64, videoMimeType, hasVideo, videoError, ...cleanData } = videoData;\n      postData = cleanData;\n    }\n  } catch (e) {\n    // Try non-video path\n    try {\n      const prepareImage = $('Prepare Image for Gemini');\n      if (prepareImage && prepareImage.item) {\n        const imageData = prepareImage.item.json;\n        // Remove temporary image fields\n        const { imageBase64, imageMimeType, hasImage, imageError, ...cleanData } = imageData;\n        postData = cleanData;\n      }\n    } catch (e2) {\n      // Fallback: try to extract from response or use empty object\n      postData = {};\n    }\n  }\n  \n  let aiInsights = {};\n  \n  try {\n    // Gemini response structure\n    const content = response.candidates?.[0]?.content?.parts?.[0]?.text || '';\n    \n    // Extract JSON from response (might be wrapped in markdown code blocks)\n    let jsonText = content.trim();\n    if (jsonText.startsWith('```json')) {\n      jsonText = jsonText.replace(/```json\\s*/g, '').replace(/```\\s*/g, '');\n    } else if (jsonText.startsWith('```')) {\n      jsonText = jsonText.replace(/```\\s*/g, '');\n    }\n    \n    aiInsights = JSON.parse(jsonText);\n  } catch (error) {\n    // Fallback: create structured object with raw text\n    aiInsights = {\n      rawAnalysis: response.candidates?.[0]?.content?.parts?.[0]?.text || 'Analysis failed',\n      error: error.message\n    };\n  }\n  \n  // Merge post data with AI insights\n  // If postData is empty, we'll still have aiInsights\n  return {\n    json: {\n      ...postData,\n      aiInsights\n    }\n  };\n});"
      },
      "id": "parse-ai-response",
      "name": "Parse AI Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2450, 300]
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "1ye1nbaT4GyREOJsWuiXVavc_nvXHcDMLU7hqwCqapqY",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": "Post Performance Data",
          "mode": "name"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Post ID": "={{ $json.id }}",
            "URL": "={{ $json.permalink_url }}",
            "Date": "={{ $json.created_time }}",
            "Type": "={{ $json.isVideo ? 'Video' : 'Non-Video' }}",
            "Copy": "={{ $json.message || '' }}",
            "Impressions": "={{ $json.metrics.impressions }}",
            "Reach": "={{ $json.metrics.reach }}",
            "Reactions": "={{ $json.metrics.reactions }}",
            "Comments": "={{ $json.metrics.comments }}",
            "Shares": "={{ $json.metrics.shares }}",
            "Clicks": "={{ $json.metrics.clicks }}",
            "Engaged Users": "={{ $json.metrics.engagedUsers }}",
            "Negative Feedback": "={{ $json.metrics.negativeFeedback }}",
            "Engagement Rate": "={{ $json.rates.engagementRate }}",
            "Share Rate": "={{ $json.rates.shareRate }}",
            "Click Rate": "={{ $json.rates.clickRate }}",
            "Performance Score": "={{ $json.performanceScore }}",
            "Category": "={{ $json.category }}",
            "Video URL": "={{ $json.source || 'N/A' }}",
            "Video Length": "={{ $json.length || 'N/A' }}",
            "Video Format": "={{ $json.format || 'N/A' }}",
            "Video Views": "={{ $json.metrics.videoViews || 'N/A' }}",
            "Video Completion Rate": "={{ $json.metrics.videoCompletionRate || 'N/A' }}"
          }
        },
        "options": {}
      },
      "id": "write-performance-data",
      "name": "Write Performance Data",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.4,
      "position": [2650, 300],
      "credentials": {
        "googleServiceAccount": {
          "name": "Google Service Account account"
        }
      }
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "1ye1nbaT4GyREOJsWuiXVavc_nvXHcDMLU7hqwCqapqY",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": "AI Analysis",
          "mode": "name"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Post ID": "={{ $json.id }}",
            "URL": "={{ $json.permalink_url }}",
            "Hook Effectiveness": "={{ $json.aiInsights.hookEffectiveness || 'N/A' }}",
            "Pacing & Retention": "={{ $json.aiInsights.pacingRetention || 'N/A' }}",
            "Completion Factors": "={{ $json.aiInsights.completionFactors || 'N/A' }}",
            "Visual Storytelling": "={{ $json.aiInsights.visualStorytelling || 'N/A' }}",
            "Audio Impact": "={{ $json.aiInsights.audioImpact || 'N/A' }}",
            "Copy Effectiveness": "={{ $json.aiInsights.copyEffectiveness || 'N/A' }}",
            "Shareability Factors": "={{ $json.aiInsights.shareabilityFactors || 'N/A' }}",
            "Audience Resonance": "={{ $json.aiInsights.audienceResonance || 'N/A' }}",
            "Engagement Triggers": "={{ $json.aiInsights.engagementTriggers || 'N/A' }}",
            "Replication Framework": "={{ $json.aiInsights.replicationFramework || 'N/A' }}",
            "Format Effectiveness": "={{ $json.aiInsights.formatEffectiveness || 'N/A' }}",
            "Raw Analysis": "={{ JSON.stringify($json.aiInsights) }}"
          }
        },
        "options": {}
      },
      "id": "write-ai-insights",
      "name": "Write AI Insights",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.4,
      "position": [2850, 300],
      "credentials": {
        "googleServiceAccount": {
          "name": "Google Service Account account"
        }
      }
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByIndex",
        "options": {}
      },
      "id": "aggregate-posts",
      "name": "Aggregate Posts",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [2950, 300]
    },
    {
      "parameters": {
        "jsCode": "// Generate weekly summary from all processed posts\nconst allItems = $input.all();\n\nif (allItems.length === 0) {\n  return {\n    json: {\n      week: new Date().toISOString().split('T')[0],\n      postsCount: 0,\n      message: 'No new posts to analyze'\n    }\n  };\n}\n\n// Extract all posts from aggregated data\nconst allPosts = allItems.map(item => item.json);\n\n// Calculate averages\nconst avgScore = allPosts.reduce((sum, post) => sum + (post.performanceScore || 0), 0) / allPosts.length;\nconst avgImpressions = allPosts.reduce((sum, post) => sum + (post.metrics?.impressions || 0), 0) / allPosts.length;\nconst avgEngagementRate = allPosts.reduce((sum, post) => sum + (post.rates?.engagementRate || 0), 0) / allPosts.length;\n\n// Find best post\nconst bestPost = allPosts.reduce((best, current) => {\n  return (current.performanceScore || 0) > (best.performanceScore || 0) ? current : best;\n}, allPosts[0]);\n\n// Count formats\nconst videoCount = allPosts.filter(post => post.isVideo).length;\nconst nonVideoCount = allPosts.length - videoCount;\n\n// Extract winning patterns and failures from AI insights\nconst winningPatterns = [];\nconst commonFailures = [];\n\nallPosts.forEach(post => {\n  const insights = post.aiInsights || {};\n  const score = post.performanceScore || 0;\n  \n  if (score >= 5) {\n    // Winning patterns\n    if (insights.hookEffectiveness && insights.hookEffectiveness !== 'N/A') {\n      winningPatterns.push(insights.hookEffectiveness.substring(0, 100));\n    }\n    if (insights.engagementTriggers && insights.engagementTriggers !== 'N/A') {\n      winningPatterns.push(insights.engagementTriggers.substring(0, 100));\n    }\n    if (insights.copyEffectiveness && insights.copyEffectiveness !== 'N/A') {\n      winningPatterns.push(insights.copyEffectiveness.substring(0, 100));\n    }\n  } else if (score < 2) {\n    // Failures\n    if (insights.copyEffectiveness && insights.copyEffectiveness !== 'N/A') {\n      commonFailures.push(insights.copyEffectiveness.substring(0, 100));\n    }\n  }\n});\n\n// Get current week number\nconst now = new Date();\nconst start = new Date(now.getFullYear(), 0, 1);\nconst days = Math.floor((now - start) / (24 * 60 * 60 * 1000));\nconst weekNumber = Math.ceil((days + start.getDay() + 1) / 7);\n\n// Generate playbook text\nconst winningText = winningPatterns.slice(0, 3).join(', ') || 'No clear patterns identified';\nconst failureText = commonFailures.slice(0, 3).join(', ') || 'No clear failures identified';\n\nconst playbook = `ZZUPER PLAYBOOK - Week ${weekNumber}\nPosts: ${allPosts.length} | Avg Score: ${avgScore.toFixed(1)}/10\nBest: ${bestPost.permalink_url} - ${bestPost.performanceScore.toFixed(1)}/10\n\n✅ WINNING: ${winningText}\n❌ AVOID: ${failureText}\nFORMAT: Video: ${videoCount} | Image/Text: ${nonVideoCount}`;\n\nreturn {\n  json: {\n    week: weekNumber,\n    weekDate: now.toISOString().split('T')[0],\n    postsCount: allPosts.length,\n    avgScore: parseFloat(avgScore.toFixed(2)),\n    avgImpressions: parseFloat(avgImpressions.toFixed(0)),\n    avgEngagementRate: parseFloat(avgEngagementRate.toFixed(2)),\n    bestPostUrl: bestPost.permalink_url,\n    bestPostScore: bestPost.performanceScore,\n    videoCount,\n    nonVideoCount,\n    winningPatterns: winningPatterns.slice(0, 5).join(' | ') || 'N/A',\n    commonFailures: commonFailures.slice(0, 5).join(' | ') || 'N/A',\n    playbook,\n    lastPostId: allPosts[allPosts.length - 1].id\n  }\n};"
      },
      "id": "generate-summary",
      "name": "Generate Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3050, 300]
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "1ye1nbaT4GyREOJsWuiXVavc_nvXHcDMLU7hqwCqapqY",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": "Weekly Patterns",
          "mode": "name"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Week": "={{ $json.week }}",
            "Week Date": "={{ $json.weekDate }}",
            "Posts Count": "={{ $json.postsCount }}",
            "Avg Score": "={{ $json.avgScore }}",
            "Avg Impressions": "={{ $json.avgImpressions }}",
            "Avg Engagement Rate": "={{ $json.avgEngagementRate }}",
            "Best Post URL": "={{ $json.bestPostUrl }}",
            "Best Post Score": "={{ $json.bestPostScore }}",
            "Winning Patterns": "={{ $json.winningPatterns }}",
            "Common Failures": "={{ $json.commonFailures }}",
            "Video Count": "={{ $json.videoCount }}",
            "Non-Video Count": "={{ $json.nonVideoCount }}",
            "Playbook": "={{ $json.playbook }}"
          }
        },
        "options": {}
      },
      "id": "write-weekly-patterns",
      "name": "Write Weekly Patterns",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.4,
      "position": [3250, 300],
      "credentials": {
        "googleServiceAccount": {
          "name": "Google Service Account account"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": {
          "__rl": true,
          "value": "1ye1nbaT4GyREOJsWuiXVavc_nvXHcDMLU7hqwCqapqY",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": "Tracker",
          "mode": "name"
        },
        "columnToMatchOn": "Last Run Date",
        "valueToMatchOn": "={{ $('Read Tracker').item.json['Last Run Date'] || '' }}",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Last Run Date": "={{ $('Generate Summary').item.json.weekDate }}",
            "Last Post ID": "={{ $('Generate Summary').item.json.lastPostId }}",
            "Posts Added": "={{ $('Generate Summary').item.json.postsCount }}"
          }
        },
        "options": {}
      },
      "id": "update-tracker",
      "name": "Update Tracker",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.4,
      "position": [3450, 300],
      "credentials": {
        "googleServiceAccount": {
          "name": "Google Service Account account"
        }
      }
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Read Tracker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Tracker": {
      "main": [
        [
          {
            "node": "Calculate Date Range",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Date Range": {
      "main": [
        [
          {
            "node": "Fetch Posts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Posts": {
      "main": [
        [
          {
            "node": "Extract Posts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Posts": {
      "main": [
        [
          {
            "node": "Filter New",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter New": {
      "main": [
        [
          {
            "node": "Get Insights",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Insights": {
      "main": [
        [
          {
            "node": "Merge Insights",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Insights": {
      "main": [
        [
          {
            "node": "Calculate Metrics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Metrics": {
      "main": [
        [
          {
            "node": "Check If Video",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check If Video": {
      "main": [
        [
          {
            "node": "Merge Video Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Video Data": {
      "main": [
        [
          {
            "node": "Build AI Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build AI Prompt": {
      "main": [
        [
          {
            "node": "Split Video/Non-Video",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Video/Non-Video": {
      "main": [
        [
          {
            "node": "Download Video",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Download Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Video": {
      "main": [
        [
          {
            "node": "Prepare Video for Gemini",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Image": {
      "main": [
        [
          {
            "node": "Prepare Image for Gemini",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Video for Gemini": {
      "main": [
        [
          {
            "node": "AI Analysis (Video)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Image for Gemini": {
      "main": [
        [
          {
            "node": "AI Analysis (Non-Video)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Analysis (Video)": {
      "main": [
        [
          {
            "node": "Parse AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Analysis (Non-Video)": {
      "main": [
        [
          {
            "node": "Parse AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Response": {
      "main": [
        [
          {
            "node": "Write Performance Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Performance Data": {
      "main": [
        [
          {
            "node": "Write AI Insights",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write AI Insights": {
      "main": [
        [
          {
            "node": "Aggregate Posts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Posts": {
      "main": [
        [
          {
            "node": "Generate Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Summary": {
      "main": [
        [
          {
            "node": "Write Weekly Patterns",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Weekly Patterns": {
      "main": [
        [
          {
            "node": "Update Tracker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-12-29T16:30:00.000Z",
  "versionId": "1"
}

